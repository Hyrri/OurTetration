import {
  __commonJS
} from "./chunk-25V3TAZK.js";

// node_modules/fast-complex/index.js
var require_fast_complex = __commonJS({
  "node_modules/fast-complex/index.js"(exports) {
    Object.defineProperty(exports, "__esModule", { value: true });
    var {
      sqrt: msqrt,
      max,
      ceil: mceil,
      floor: mfloor,
      abs: mabs,
      exp: mexp,
      log10: mlog10,
      log: mlog,
      cos: mcos,
      sin: msin,
      tan: mtan,
      asin: masin,
      acos: macos,
      atan: matan,
      atan2: matan2,
      cosh: mcosh,
      sinh: msinh,
      tanh: mtanh,
      sign: msign
    } = Math;
    var masinh = (x) => mlog(x + msqrt(x * x + 1));
    var macosh = (x) => mlog(x + msqrt(x * x - 1));
    var matanh = (x) => mlog((1 + x) / (1 - x)) / 2;
    var BASE_10 = [mlog(10), 0];
    var TWO = Object.freeze([2, 0]);
    var ONE = Object.freeze([1, 0]);
    var ZERO = Object.freeze([0, 0]);
    var I = Object.freeze([0, 1]);
    var HALF_I = Object.freeze([0, 0.5]);
    var NI = Object.freeze([0, -1]);
    var NAN = Object.freeze([NaN, NaN]);
    var EPSILON = 1e-7;
    var eq = (a, b) => mabs(a - b) <= EPSILON * max(1, mabs(a), mabs(b));
    var isNumber = (x) => typeof x === "number";
    var unsafeL2 = (c) => c[0] * c[0] + c[1] * c[1];
    var unsafeAbs = (c) => msqrt(unsafeL2(c));
    var unsafeArg = (c) => matan2(c[1], c[0]);
    var unsafeAdd = (a, b) => [a[0] + b[0], a[1] + b[1]];
    var unsafeSub = (a, b) => [a[0] - b[0], a[1] - b[1]];
    var unsafeMul = (a, b) => [
      a[0] * b[0] - a[1] * b[1],
      a[0] * b[1] + a[1] * b[0]
    ];
    var unsafeDiv = (a, b) => [
      (a[0] * b[0] + a[1] * b[1]) / unsafeL2(b),
      (a[1] * b[0] - a[0] * b[1]) / unsafeL2(b)
    ];
    var unsafeSqrt = (c) => [
      msqrt((c[0] + unsafeAbs(c)) / 2),
      msqrt((-c[0] + unsafeAbs(c)) / 2) * msign(c[1])
    ];
    var unsafeLn = (c) => [
      mlog(unsafeAbs(c)),
      unsafeArg(c)
    ];
    var unsafeExp = (c) => [
      mexp(c[0]) * mcos(c[1]),
      mexp(c[0]) * msin(c[1])
    ];
    var unsafeCos = (c) => [mcos(c[0]) * mcosh(c[1]), -msin(c[0]) * msinh(c[1])];
    var unsafeSin = (c) => [msin(c[0]) * mcosh(c[1]), mcos(c[0]) * msinh(c[1])];
    var unsafeCosh = (c) => [mcosh(c[0]) * mcos(c[1]), msinh(c[0]) * msin(c[1])];
    var unsafeSinh = (c) => [msinh(c[0]) * mcos(c[1]), mcosh(c[0]) * msin(c[1])];
    var unsafeAsin = (c) => unsafeMul(
      NI,
      unsafeLn(
        unsafeAdd(
          unsafeMul(I, c),
          unsafeSqrt(unsafeSub(ONE, unsafeMul(c, c)))
        )
      )
    );
    var unsafeAcos = (c) => unsafeMul(
      NI,
      unsafeLn(
        unsafeAdd(
          c,
          unsafeSqrt(unsafeSub(unsafeMul(c, c), ONE))
        )
      )
    );
    var unsafeAtan = (c) => unsafeMul(
      HALF_I,
      unsafeLn(
        unsafeDiv(
          [c[0], 1 + c[1]],
          [-c[0], 1 - c[1]]
        )
      )
    );
    var unsafeAsinh = (c) => {
      const r = unsafeMul(c, c);
      r[0] += 1;
      return unsafeLn(unsafeAdd(c, unsafeSqrt(r)));
    };
    var unsafeAcosh = (c) => {
      const r = unsafeMul(c, c);
      r[0] -= 1;
      return unsafeLn(unsafeAdd(c, unsafeSqrt(r)));
    };
    var unsafeAtanh = (c) => unsafeMul(
      unsafeLn(unsafeDiv(
        unsafeAdd(ONE, c),
        unsafeSub(ONE, c)
      )),
      [0.5, 0]
    );
    var isComplex = (x) => x instanceof Array && isNumber(x[0]) && isNumber(x[1]) || x instanceof Float32Array || x instanceof Float64Array;
    var zero = () => [0, 0];
    var conjugate = (c) => isComplex(c) && [c[0], -c[1]] || isNumber(c) && [c, 0] || NAN;
    var negate = (c) => isComplex(c) && [-c[0], -c[1]] || isNumber(c) && [-c, 0] || NAN;
    var add = (a, b) => isComplex(a) && (isComplex(b) && unsafeAdd(a, b) || isNumber(b) && [a[0] + b, a[1]]) || isNumber(a) && (isComplex(b) && [a + b[0], b[1]] || isNumber(b) && [a + b, 0]) || NAN;
    var sub = (a, b) => isComplex(a) && (isComplex(b) && unsafeSub(a, b) || isNumber(b) && [a[0] - b, a[1]]) || isNumber(a) && (isComplex(b) && [a - b[0], b[1]] || isNumber(b) && [a - b, 0]) || NAN;
    var mul = (a, b) => isComplex(a) && (isComplex(b) && unsafeMul(a, b) || isNumber(b) && [a[0] * b, a[1] * b]) || isNumber(a) && (isComplex(b) && [a * b[0], a * b[1]] || isNumber(b) && [a * b, 0]) || NAN;
    var div = (a, b) => isComplex(a) && (isComplex(b) && unsafeDiv(a, b) || isNumber(b) && [a[0] / b, a[1] / b]) || isNumber(a) && (isComplex(b) && [a / b[0], a / b[1]] || isNumber(b) && [a * b, 0]) || NAN;
    var reciprocal = (c) => isComplex(c) && [
      c[0] / unsafeL2(c),
      -c[1] / unsafeL2(c)
    ] || isNumber(c) && [1 / c, 0] || NAN;
    var abs = (c) => isComplex(c) && unsafeAbs(c) || (isNumber(c) ? c : NaN);
    var arg = (c) => isComplex(c) && unsafeArg(c) || (isNumber(c) ? 0 : NaN);
    var euler = (x) => isNumber(x) && [mcos(x), msin(x)] || NAN;
    var sign = (c) => isComplex(c) && [c[0] / unsafeAbs(c), c[1] / unsafeAbs(c)] || isNumber(c) && [msign(c), 0] || NAN;
    var sqrt = (c) => isComplex(c) && (eq(c[1], 0) && [msqrt(c[0]), 0] || unsafeSqrt(c)) || isNumber(c) && [msqrt(c), 0] || NAN;
    var exp = (c) => isComplex(c) && unsafeExp(c) || isNumber(c) && [mexp(c), 0] || NAN;
    var ln = (c) => isComplex(c) && unsafeLn(c) || isNumber(c) && [mlog(c), 0] || NAN;
    var log10 = (c) => isComplex(c) && unsafeDiv(unsafeLn(c), BASE_10) || isNumber(c) && [mlog10(c), 0] || NAN;
    var pow = (a, b) => isComplex(a) && isComplex(b) && unsafeExp(unsafeMul(unsafeLn(a), b)) || isNumber(a) && pow([a, 0], b) || isNumber(b) && pow(a, [b, 0]) || NAN;
    var floor = (c) => isComplex(c) && [mfloor(c[0]), mfloor(c[1])] || isNumber(c) && [mfloor(c), 0] || NAN;
    var ceil = (c) => isComplex(c) && [mceil(c[0]), mceil(c[1])] || isNumber(c) && [mceil(c), 0] || NAN;
    var polar = (radius, phi) => isNumber(radius) && isNumber(phi) && [radius * mcos(phi), radius * msin(phi)] || NAN;
    var sin = (c) => isComplex(c) && unsafeSin(c) || isNumber(c) && [msin(c), 0] || NAN;
    var cos = (c) => isComplex(c) && unsafeCos(c) || isNumber(c) && [mcos(c), 0] || NAN;
    var tan = (c) => isComplex(c) && unsafeDiv(unsafeSin(c), unsafeCos(c)) || isNumber(c) && [mtan(c), 0] || NAN;
    var asin = (c) => isComplex(c) && unsafeAsin(c) || isNumber(c) && [masin(c), 0] || NAN;
    var acos = (c) => isComplex(c) && unsafeAcos(c) || isNumber(c) && [macos(c), 0] || NAN;
    var atan = (c) => isComplex(c) && unsafeAtan(c) || isNumber(c) && [matan(c), 0] || NAN;
    var sinh = (c) => isComplex(c) && unsafeSinh(c) || isNumber(c) && [msinh(c), 0] || NAN;
    var cosh = (c) => isComplex(c) && unsafeCosh(c) || isNumber(c) && [mcosh(c), 0] || NAN;
    var tanh = (c) => isComplex(c) && unsafeDiv(unsafeSinh(c), unsafeCosh(c)) || isNumber(c) && [mtanh(c), 0] || NAN;
    var asinh = (c) => isComplex(c) && unsafeAsinh(c) || isNumber(c) && [masinh(c), 0] || NAN;
    var acosh = (c) => isComplex(c) && unsafeAcosh(c) || isNumber(c) && [macosh(c), 0] || NAN;
    var atanh = (c) => isComplex(c) && unsafeAtanh(c) || isNumber(c) && [matanh(c), 0] || NAN;
    var equals = (a, b) => isComplex(a) && isComplex(b) && eq(a[0], b[0]) && eq(a[1], b[1]) || a === b;
    exports.HALF_I = HALF_I;
    exports.I = I;
    exports.NAN = NAN;
    exports.NI = NI;
    exports.ONE = ONE;
    exports.TWO = TWO;
    exports.ZERO = ZERO;
    exports.abs = abs;
    exports.acos = acos;
    exports.acosh = acosh;
    exports.add = add;
    exports.arg = arg;
    exports.asin = asin;
    exports.asinh = asinh;
    exports.atan = atan;
    exports.atanh = atanh;
    exports.ceil = ceil;
    exports.conjugate = conjugate;
    exports.cos = cos;
    exports.cosh = cosh;
    exports.div = div;
    exports.equals = equals;
    exports.euler = euler;
    exports.exp = exp;
    exports.floor = floor;
    exports.isComplex = isComplex;
    exports.ln = ln;
    exports.log10 = log10;
    exports.mul = mul;
    exports.negate = negate;
    exports.polar = polar;
    exports.pow = pow;
    exports.reciprocal = reciprocal;
    exports.sign = sign;
    exports.sin = sin;
    exports.sinh = sinh;
    exports.sqrt = sqrt;
    exports.sub = sub;
    exports.tan = tan;
    exports.tanh = tanh;
    exports.zero = zero;
  }
});
export default require_fast_complex();
/*! Bundled license information:

fast-complex/index.js:
  (**
   * @license
   * MIT License
   *
   * Copyright (c) 2019 Alexis Munsayac
   * Permission is hereby granted, free of charge, to any person obtaining a copy
   * of this software and associated documentation files (the "Software"), to deal
   * in the Software without restriction, including without limitation the rights
   * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
   * copies of the Software, and to permit persons to whom the Software is
   * furnished to do so, subject to the following conditions:
   *
   * The above copyright notice and this permission notice shall be included in all
   * copies or substantial portions of the Software.
   *
   * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
   * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
   * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
   * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
   * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
   * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
   * SOFTWARE.
   *
   *
   * @author Alexis Munsayac <alexis.munsayac@gmail.com>
   * @copyright Alexis Munsayac 2019
   *)
*/
//# sourceMappingURL=fast-complex.js.map
